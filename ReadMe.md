# Traveling Salesman Problem (TSP) using Genetic Algorithm

This project solves the Traveling Salesman Problem (TSP) using a Genetic Algorithm (GA). The TSP is an NP-hard problem where, given a list of cities and the distances between them, the objective is to find the shortest possible tour that visits each city exactly once and returns to the origin city.

## Problem Definition

The input is a list of cities, represented as coordinates, and the task is to find the shortest possible route that visits all cities and returns to the start. The Genetic Algorithm attempts to solve this problem by simulating the process of natural selection, iteratively improving the candidate solutions over generations.

## How It Works

### 1. **Reading Input**

The function `readInput` reads a list of cities and their coordinates from a file (`input.txt`). The file structure is:
- The first line is the number of cities.
- The subsequent lines contain the coordinates of each city.

### 2. **Initial Population**

The algorithm begins by creating a population of random candidate solutions (routes). Each candidate is a random permutation of the cities. The `createInitialPopulation` function generates this initial population, and each route's fitness is calculated based on its total distance.

### 3. **Fitness Calculation**

The fitness of a solution is the inverse of the total distance of the route. The total distance is calculated by summing up the Euclidean distances between consecutive cities. The shorter the distance, the higher the fitness.

### 4. **Selection (Mating Pool)**

A mating pool is created by selecting parents based on their fitness. The selection is probabilistic, meaning fitter candidates have a higher chance of being chosen. The `createMatingPool` function handles this by assigning selection probabilities based on the fitness values.

### 5. **Crossover (Breeding)**

Once the parents are selected, new offspring (children) are generated by combining parts of two parent solutions. Two crossover techniques are used: **Order Crossover** and **Cycle Crossover**.

- **Order Crossover** preserves a subsequence from one parent and fills the rest of the cities in the child from the other parent, in order.
  
- **Cycle Crossover** ensures that each city in the child inherits its position from one of the parents.

### 6. **Mutation**

To maintain diversity and avoid premature convergence, random mutations are applied to the offspring. Three types of mutations are implemented:

- **Swap Mutation**: Swaps two cities in the tour.
- **Scramble Mutation**: Randomly shuffles a subset of cities.
- **Inversion Mutation**: Reverses the order of a subset of cities.

The mutation rate increases if the population has stagnated (i.e., thereâ€™s no improvement over several generations).

### 7. **Creating New Generation**

In each generation, new offspring are created by performing selection, crossover, and mutation. The elite (top performers) from the previous generation are carried over to the next. The function `createNewGeneration` creates the next generation by breeding and mutating the population.

### 8. **Convergence Check**

The algorithm tracks how often the best solution stays the same (stagnation). If the solution does not improve after a certain number of generations, the mutation rate is increased to encourage exploration.

### 9. **Writing Output**

The best solution is written to an output file (`output.txt`) with the total distance and the tour sequence.

### 10. **Genetic Algorithm Execution**

The `geneticAlgorithm` function orchestrates the overall flow of the algorithm, including initialization, selection, crossover, mutation, and convergence checking. It runs for a number of generations based on the number of cities and returns the best solution found.

## Running the Code

1. Prepare an `input.txt` file with the number of cities and their coordinates.
2. Run the script. The genetic algorithm will search for the shortest route through the cities.
3. The result will be written to `output.txt`.

## Parameters

- `populationSize`: The size of the population in each generation (default 500).
- `eliteSize`: The number of top-performing solutions carried over to the next generation (default 15).
- The number of generations is dynamically chosen based on the number of cities.

## Dependencies

This project requires:
- Python 3.x
- NumPy
- SciPy

## Conclusion

This project implements a Genetic Algorithm to solve the Traveling Salesman Problem, efficiently finding near-optimal solutions for large problem instances. It includes techniques such as crossover, mutation, and elitism to simulate evolution and improve solutions over generations.

## Contact

If you have questions, suggestions, or would like to collaborate on this project, please feel free to reach out to me:

- Email: glendhingra27@gmail.com

I appreciate your support and contributions to this project.